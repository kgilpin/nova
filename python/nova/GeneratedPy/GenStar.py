'''
GenStar.py
Tue Mar 29 11:44:59 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_gameAttr = None
_nameAttr = None
_xAttr = None
_yAttr = None
_wealthAttr = None
_numShipsAttr = None
_numFactoriesAttr = None
_hasSpyShieldAttr = None
_hasDeathShieldAttr = None
_ownerAttr = None
_homeWorldOfAttr = None
_isDeadAttr = None
_standingOrdersAttr = None

import types
from mx import DateTime
import sys
from os.path import dirname
sys.path.insert(0, dirname(dirname(dirname(__file__))))
from nova.GameObject import GameObject
del sys.path[0]

from types import InstanceType, LongType
from MiddleKit.Run.SQLObjectStore import ObjRefError



class GenStar(GameObject):

	def __init__(self):
		GameObject.__init__(self)
		self._name           = None
		self._x              = None
		self._y              = None
		self._wealth         = 10
		self._numShips       = 0
		self._numFactories   = 0
		self._hasSpyShield   = 0
		self._hasDeathShield = 0
		self._owner          = None
		self._homeWorldOf    = None
		self._isDead         = 0
		self._standingOrders = []

	def construct(self, game, name, x, y):
		# Construct the Star with all the required attributes that do not have default values
		self.setGame( game )
		self.setName( name )
		self.setX( x )
		self.setY( y )

	def readStoreData(self, store, row):
		if not self._mk_inStore:
			self._standingOrders = None
		GameObject.readStoreData(self, store, row)


	def name(self):
		return self._name

	def setName(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._name
		self._name = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _nameAttr
			if _nameAttr is None:
				_nameAttr = self.klass().lookupAttr('name')
				if not _nameAttr.shouldRegisterChanges():
					_nameAttr = 0
			if _nameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['name'] = _nameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def x(self):
		return self._x

	def setX(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._x
		self._x = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _xAttr
			if _xAttr is None:
				_xAttr = self.klass().lookupAttr('x')
				if not _xAttr.shouldRegisterChanges():
					_xAttr = 0
			if _xAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['x'] = _xAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def y(self):
		return self._y

	def setY(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._y
		self._y = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _yAttr
			if _yAttr is None:
				_yAttr = self.klass().lookupAttr('y')
				if not _yAttr.shouldRegisterChanges():
					_yAttr = 0
			if _yAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['y'] = _yAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def wealth(self):
		return self._wealth

	def setWealth(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._wealth
		self._wealth = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _wealthAttr
			if _wealthAttr is None:
				_wealthAttr = self.klass().lookupAttr('wealth')
				if not _wealthAttr.shouldRegisterChanges():
					_wealthAttr = 0
			if _wealthAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['wealth'] = _wealthAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def numShips(self):
		return self._numShips

	def setNumShips(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._numShips
		self._numShips = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _numShipsAttr
			if _numShipsAttr is None:
				_numShipsAttr = self.klass().lookupAttr('numShips')
				if not _numShipsAttr.shouldRegisterChanges():
					_numShipsAttr = 0
			if _numShipsAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['numShips'] = _numShipsAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def numFactories(self):
		return self._numFactories

	def setNumFactories(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._numFactories
		self._numFactories = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _numFactoriesAttr
			if _numFactoriesAttr is None:
				_numFactoriesAttr = self.klass().lookupAttr('numFactories')
				if not _numFactoriesAttr.shouldRegisterChanges():
					_numFactoriesAttr = 0
			if _numFactoriesAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['numFactories'] = _numFactoriesAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def hasSpyShield(self):
		return self._hasSpyShield

	def setHasSpyShield(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.IntType:
				raise TypeError, 'expecting int for bool, but got value %r of type %r instead' % (value, type(value))
			if value not in (0, 1):
				raise ValueError, 'expecting 0 or 1 for bool, but got %s instead' % value

		# set the attribute
		origValue = self._hasSpyShield
		self._hasSpyShield = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _hasSpyShieldAttr
			if _hasSpyShieldAttr is None:
				_hasSpyShieldAttr = self.klass().lookupAttr('hasSpyShield')
				if not _hasSpyShieldAttr.shouldRegisterChanges():
					_hasSpyShieldAttr = 0
			if _hasSpyShieldAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['hasSpyShield'] = _hasSpyShieldAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def hasDeathShield(self):
		return self._hasDeathShield

	def setHasDeathShield(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.IntType:
				raise TypeError, 'expecting int for bool, but got value %r of type %r instead' % (value, type(value))
			if value not in (0, 1):
				raise ValueError, 'expecting 0 or 1 for bool, but got %s instead' % value

		# set the attribute
		origValue = self._hasDeathShield
		self._hasDeathShield = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _hasDeathShieldAttr
			if _hasDeathShieldAttr is None:
				_hasDeathShieldAttr = self.klass().lookupAttr('hasDeathShield')
				if not _hasDeathShieldAttr.shouldRegisterChanges():
					_hasDeathShieldAttr = 0
			if _hasDeathShieldAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['hasDeathShield'] = _hasDeathShieldAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def owner(self):
		if self._owner is not None and type(self._owner) is not InstanceType:
			try:
				self.__dict__['_owner'] = self._mk_store.fetchObjRef(self._owner)
			except ObjRefError, e:
				self.__dict__['_owner'] = self.objRefErrorWasRaised(e, 'Star', 'owner')
		return self._owner

	def setOwner(self, value):
		
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Player import Player
			if not isinstance(value, Player):
				raise TypeError, 'expecting Player, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._owner
		self._owner = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ownerAttr
			if _ownerAttr is None:
				_ownerAttr = self.klass().lookupAttr('owner')
				if not _ownerAttr.shouldRegisterChanges():
					_ownerAttr = 0
			if _ownerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['owner'] = _ownerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def homeWorldOf(self):
		if self._homeWorldOf is not None and type(self._homeWorldOf) is not InstanceType:
			try:
				self.__dict__['_homeWorldOf'] = self._mk_store.fetchObjRef(self._homeWorldOf)
			except ObjRefError, e:
				self.__dict__['_homeWorldOf'] = self.objRefErrorWasRaised(e, 'Star', 'homeWorldOf')
		return self._homeWorldOf

	def setHomeWorldOf(self, value):
		
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Player import Player
			if not isinstance(value, Player):
				raise TypeError, 'expecting Player, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._homeWorldOf
		self._homeWorldOf = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _homeWorldOfAttr
			if _homeWorldOfAttr is None:
				_homeWorldOfAttr = self.klass().lookupAttr('homeWorldOf')
				if not _homeWorldOfAttr.shouldRegisterChanges():
					_homeWorldOfAttr = 0
			if _homeWorldOfAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['homeWorldOf'] = _homeWorldOfAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def isDead(self):
		return self._isDead

	def setIsDead(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.IntType:
				raise TypeError, 'expecting int for bool, but got value %r of type %r instead' % (value, type(value))
			if value not in (0, 1):
				raise ValueError, 'expecting 0 or 1 for bool, but got %s instead' % value

		# set the attribute
		origValue = self._isDead
		self._isDead = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _isDeadAttr
			if _isDeadAttr is None:
				_isDeadAttr = self.klass().lookupAttr('isDead')
				if not _isDeadAttr.shouldRegisterChanges():
					_isDeadAttr = 0
			if _isDeadAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['isDead'] = _isDeadAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def standingOrders(self):
		if self._standingOrders is None:
			from nova.StandingOrder import StandingOrder
			self._standingOrders = self._mk_store.fetchObjectsOfClass(StandingOrder, clauses='where starId=%i' % self.sqlObjRef())
		return self._standingOrders

	def addToStandingOrders(self, value):
		assert value is not None
		from nova.StandingOrder import StandingOrder
		assert isinstance(value, StandingOrder)
		assert value.star() is None
		self.standingOrders().append(value)
		value.setStar(self)
		store = self.store()
		if value.serialNum()==0 and self.isInStore():
			store.addObject(value)

