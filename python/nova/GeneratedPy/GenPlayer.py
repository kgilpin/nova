'''
GenPlayer.py
Tue Mar 29 11:44:59 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_gameAttr = None
_userAttr = None
_nameAttr = None
_wealthAttr = None
_battlePowerAttr = None
_rangeAttr = None
_speedAttr = None

import types
from mx import DateTime
import sys
from os.path import dirname
sys.path.insert(0, dirname(dirname(dirname(__file__))))
from nova.GameObject import GameObject
del sys.path[0]

from types import InstanceType, LongType
from MiddleKit.Run.SQLObjectStore import ObjRefError



class GenPlayer(GameObject):

	def __init__(self):
		GameObject.__init__(self)
		self._user        = None
		self._name        = None
		self._wealth      = 250
		self._battlePower = 100
		self._range       = 10.0
		self._speed       = 0.5

	def construct(self, game, user, name):
		# Construct the Player with all the required attributes that do not have default values
		self.setGame( game )
		self.setUser( user )
		self.setName( name )

	def user(self):
		if self._user is not None and type(self._user) is not InstanceType:
			try:
				self.__dict__['_user'] = self._mk_store.fetchObjRef(self._user)
			except ObjRefError, e:
				self.__dict__['_user'] = self.objRefErrorWasRaised(e, 'Player', 'user')
		return self._user

	def setUser(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.User import User
			if not isinstance(value, User):
				raise TypeError, 'expecting User, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._user
		self._user = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _userAttr
			if _userAttr is None:
				_userAttr = self.klass().lookupAttr('user')
				if not _userAttr.shouldRegisterChanges():
					_userAttr = 0
			if _userAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['user'] = _userAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def name(self):
		return self._name

	def setName(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._name
		self._name = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _nameAttr
			if _nameAttr is None:
				_nameAttr = self.klass().lookupAttr('name')
				if not _nameAttr.shouldRegisterChanges():
					_nameAttr = 0
			if _nameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['name'] = _nameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def wealth(self):
		return self._wealth

	def setWealth(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._wealth
		self._wealth = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _wealthAttr
			if _wealthAttr is None:
				_wealthAttr = self.klass().lookupAttr('wealth')
				if not _wealthAttr.shouldRegisterChanges():
					_wealthAttr = 0
			if _wealthAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['wealth'] = _wealthAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def battlePower(self):
		return self._battlePower

	def setBattlePower(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._battlePower
		self._battlePower = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _battlePowerAttr
			if _battlePowerAttr is None:
				_battlePowerAttr = self.klass().lookupAttr('battlePower')
				if not _battlePowerAttr.shouldRegisterChanges():
					_battlePowerAttr = 0
			if _battlePowerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['battlePower'] = _battlePowerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def range(self):
		return self._range

	def setRange(self, value):
		assert value is not None
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._range
		self._range = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _rangeAttr
			if _rangeAttr is None:
				_rangeAttr = self.klass().lookupAttr('range')
				if not _rangeAttr.shouldRegisterChanges():
					_rangeAttr = 0
			if _rangeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['range'] = _rangeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def speed(self):
		return self._speed

	def setSpeed(self, value):
		assert value is not None
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._speed
		self._speed = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _speedAttr
			if _speedAttr is None:
				_speedAttr = self.klass().lookupAttr('speed')
				if not _speedAttr.shouldRegisterChanges():
					_speedAttr = 0
			if _speedAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['speed'] = _speedAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

