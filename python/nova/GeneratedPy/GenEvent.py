'''
GenEvent.py
Tue Mar 29 11:44:59 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_gameAttr = None
_executionTimeAttr = None
_eventCounterAttr = None
_playerAttr = None
_statusAttr = None

import types
from mx import DateTime
import sys
from os.path import dirname
sys.path.insert(0, dirname(dirname(dirname(__file__))))
from nova.GameObject import GameObject
del sys.path[0]

from types import InstanceType, LongType
from MiddleKit.Run.SQLObjectStore import ObjRefError



class GenEvent(GameObject):

	def __init__(self):
		GameObject.__init__(self)
		self._executionTime = None
		self._eventCounter  = -1
		self._player        = None
		self._status        = 'Pending'

	def construct(self, game, executionTime, player):
		# Construct the Event with all the required attributes that do not have default values
		self.setGame( game )
		self.setExecutionTime( executionTime )
		self.setPlayer( player )

	def executionTime(self):
		return self._executionTime

	def setExecutionTime(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is type(''):
				value = DateTime.DateTimeFrom(value)
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._executionTime
		self._executionTime = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _executionTimeAttr
			if _executionTimeAttr is None:
				_executionTimeAttr = self.klass().lookupAttr('executionTime')
				if not _executionTimeAttr.shouldRegisterChanges():
					_executionTimeAttr = 0
			if _executionTimeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['executionTime'] = _executionTimeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def eventCounter(self):
		return self._eventCounter

	def setEventCounter(self, value):
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._eventCounter
		self._eventCounter = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _eventCounterAttr
			if _eventCounterAttr is None:
				_eventCounterAttr = self.klass().lookupAttr('eventCounter')
				if not _eventCounterAttr.shouldRegisterChanges():
					_eventCounterAttr = 0
			if _eventCounterAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['eventCounter'] = _eventCounterAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def player(self):
		if self._player is not None and type(self._player) is not InstanceType:
			try:
				self.__dict__['_player'] = self._mk_store.fetchObjRef(self._player)
			except ObjRefError, e:
				self.__dict__['_player'] = self.objRefErrorWasRaised(e, 'Event', 'player')
		return self._player

	def setPlayer(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Player import Player
			if not isinstance(value, Player):
				raise TypeError, 'expecting Player, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._player
		self._player = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _playerAttr
			if _playerAttr is None:
				_playerAttr = self.klass().lookupAttr('player')
				if not _playerAttr.shouldRegisterChanges():
					_playerAttr = 0
			if _playerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['player'] = _playerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def status(self):
		return self._status

	def setStatus(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type for enum, but got value %r of type %r instead' % (value, type(value))
			attr = self.klass().lookupAttr('status')
			if not attr.hasEnum(value):
				raise ValueError, 'expecting one of %r, but got %r instead' % (attr.enums(), value)

		# set the attribute
		origValue = self._status
		self._status = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _statusAttr
			if _statusAttr is None:
				_statusAttr = self.klass().lookupAttr('status')
				if not _statusAttr.shouldRegisterChanges():
					_statusAttr = 0
			if _statusAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['status'] = _statusAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

