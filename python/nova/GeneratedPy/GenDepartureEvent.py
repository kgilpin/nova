'''
GenDepartureEvent.py
Tue Mar 29 11:44:59 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_gameAttr = None
_executionTimeAttr = None
_eventCounterAttr = None
_playerAttr = None
_statusAttr = None
_numShipsAttr = None
_originAttr = None
_destinationAttr = None
_arrivalTimeAttr = None
_unitTypeAttr = None
_finalDestinationAttr = None

import types
from mx import DateTime
import sys
from os.path import dirname
sys.path.insert(0, dirname(dirname(dirname(__file__))))
from nova.Event import Event
del sys.path[0]

from types import InstanceType, LongType
from MiddleKit.Run.SQLObjectStore import ObjRefError



class GenDepartureEvent(Event):

	def __init__(self):
		Event.__init__(self)
		self._numShips         = None
		self._origin           = None
		self._destination      = None
		self._arrivalTime      = None
		self._unitType         = None
		self._finalDestination = None

	def construct(self, game, executionTime, player, numShips, origin, destination, unitType):
		# Construct the DepartureEvent with all the required attributes that do not have default values
		self.setGame( game )
		self.setExecutionTime( executionTime )
		self.setPlayer( player )
		self.setNumShips( numShips )
		self.setOrigin( origin )
		self.setDestination( destination )
		self.setUnitType( unitType )

	def numShips(self):
		return self._numShips

	def setNumShips(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._numShips
		self._numShips = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _numShipsAttr
			if _numShipsAttr is None:
				_numShipsAttr = self.klass().lookupAttr('numShips')
				if not _numShipsAttr.shouldRegisterChanges():
					_numShipsAttr = 0
			if _numShipsAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['numShips'] = _numShipsAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def origin(self):
		if self._origin is not None and type(self._origin) is not InstanceType:
			try:
				self.__dict__['_origin'] = self._mk_store.fetchObjRef(self._origin)
			except ObjRefError, e:
				self.__dict__['_origin'] = self.objRefErrorWasRaised(e, 'DepartureEvent', 'origin')
		return self._origin

	def setOrigin(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Star import Star
			if not isinstance(value, Star):
				raise TypeError, 'expecting Star, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._origin
		self._origin = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _originAttr
			if _originAttr is None:
				_originAttr = self.klass().lookupAttr('origin')
				if not _originAttr.shouldRegisterChanges():
					_originAttr = 0
			if _originAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['origin'] = _originAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def destination(self):
		if self._destination is not None and type(self._destination) is not InstanceType:
			try:
				self.__dict__['_destination'] = self._mk_store.fetchObjRef(self._destination)
			except ObjRefError, e:
				self.__dict__['_destination'] = self.objRefErrorWasRaised(e, 'DepartureEvent', 'destination')
		return self._destination

	def setDestination(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Star import Star
			if not isinstance(value, Star):
				raise TypeError, 'expecting Star, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._destination
		self._destination = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _destinationAttr
			if _destinationAttr is None:
				_destinationAttr = self.klass().lookupAttr('destination')
				if not _destinationAttr.shouldRegisterChanges():
					_destinationAttr = 0
			if _destinationAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['destination'] = _destinationAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def arrivalTime(self):
		return self._arrivalTime

	def setArrivalTime(self, value):
		# have DateTime
		if value is not None:
			if type(value) is type(''):
				value = DateTime.DateTimeFrom(value)
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._arrivalTime
		self._arrivalTime = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _arrivalTimeAttr
			if _arrivalTimeAttr is None:
				_arrivalTimeAttr = self.klass().lookupAttr('arrivalTime')
				if not _arrivalTimeAttr.shouldRegisterChanges():
					_arrivalTimeAttr = 0
			if _arrivalTimeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['arrivalTime'] = _arrivalTimeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def unitType(self):
		return self._unitType

	def setUnitType(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type for enum, but got value %r of type %r instead' % (value, type(value))
			attr = self.klass().lookupAttr('unitType')
			if not attr.hasEnum(value):
				raise ValueError, 'expecting one of %r, but got %r instead' % (attr.enums(), value)

		# set the attribute
		origValue = self._unitType
		self._unitType = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _unitTypeAttr
			if _unitTypeAttr is None:
				_unitTypeAttr = self.klass().lookupAttr('unitType')
				if not _unitTypeAttr.shouldRegisterChanges():
					_unitTypeAttr = 0
			if _unitTypeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['unitType'] = _unitTypeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def finalDestination(self):
		if self._finalDestination is not None and type(self._finalDestination) is not InstanceType:
			try:
				self.__dict__['_finalDestination'] = self._mk_store.fetchObjRef(self._finalDestination)
			except ObjRefError, e:
				self.__dict__['_finalDestination'] = self.objRefErrorWasRaised(e, 'DepartureEvent', 'finalDestination')
		return self._finalDestination

	def setFinalDestination(self, value):
		
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Star import Star
			if not isinstance(value, Star):
				raise TypeError, 'expecting Star, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._finalDestination
		self._finalDestination = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _finalDestinationAttr
			if _finalDestinationAttr is None:
				_finalDestinationAttr = self.klass().lookupAttr('finalDestination')
				if not _finalDestinationAttr.shouldRegisterChanges():
					_finalDestinationAttr = 0
			if _finalDestinationAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['finalDestination'] = _finalDestinationAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

