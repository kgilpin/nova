'''
GenBattleEvent.py
Tue Mar 29 11:44:59 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_gameAttr = None
_executionTimeAttr = None
_eventCounterAttr = None
_playerAttr = None
_statusAttr = None
_starAttr = None
_attackerAttr = None
_defenderAttr = None
_victorAttr = None
_numAttackingShipsAttr = None
_numDefendingShipsAttr = None
_numShipsLostAttr = None

import types
from mx import DateTime
import sys
from os.path import dirname
sys.path.insert(0, dirname(dirname(dirname(__file__))))
from nova.Event import Event
del sys.path[0]

from types import InstanceType, LongType
from MiddleKit.Run.SQLObjectStore import ObjRefError



class GenBattleEvent(Event):

	def __init__(self):
		Event.__init__(self)
		self._star              = None
		self._attacker          = None
		self._defender          = None
		self._victor            = None
		self._numAttackingShips = None
		self._numDefendingShips = None
		self._numShipsLost      = None

	def construct(self, game, executionTime, player, star, attacker, defender, victor, numAttackingShips, numDefendingShips, numShipsLost):
		# Construct the BattleEvent with all the required attributes that do not have default values
		self.setGame( game )
		self.setExecutionTime( executionTime )
		self.setPlayer( player )
		self.setStar( star )
		self.setAttacker( attacker )
		self.setDefender( defender )
		self.setVictor( victor )
		self.setNumAttackingShips( numAttackingShips )
		self.setNumDefendingShips( numDefendingShips )
		self.setNumShipsLost( numShipsLost )

	def star(self):
		if self._star is not None and type(self._star) is not InstanceType:
			try:
				self.__dict__['_star'] = self._mk_store.fetchObjRef(self._star)
			except ObjRefError, e:
				self.__dict__['_star'] = self.objRefErrorWasRaised(e, 'BattleEvent', 'star')
		return self._star

	def setStar(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Star import Star
			if not isinstance(value, Star):
				raise TypeError, 'expecting Star, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._star
		self._star = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _starAttr
			if _starAttr is None:
				_starAttr = self.klass().lookupAttr('star')
				if not _starAttr.shouldRegisterChanges():
					_starAttr = 0
			if _starAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['star'] = _starAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def attacker(self):
		if self._attacker is not None and type(self._attacker) is not InstanceType:
			try:
				self.__dict__['_attacker'] = self._mk_store.fetchObjRef(self._attacker)
			except ObjRefError, e:
				self.__dict__['_attacker'] = self.objRefErrorWasRaised(e, 'BattleEvent', 'attacker')
		return self._attacker

	def setAttacker(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Player import Player
			if not isinstance(value, Player):
				raise TypeError, 'expecting Player, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._attacker
		self._attacker = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _attackerAttr
			if _attackerAttr is None:
				_attackerAttr = self.klass().lookupAttr('attacker')
				if not _attackerAttr.shouldRegisterChanges():
					_attackerAttr = 0
			if _attackerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['attacker'] = _attackerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def defender(self):
		if self._defender is not None and type(self._defender) is not InstanceType:
			try:
				self.__dict__['_defender'] = self._mk_store.fetchObjRef(self._defender)
			except ObjRefError, e:
				self.__dict__['_defender'] = self.objRefErrorWasRaised(e, 'BattleEvent', 'defender')
		return self._defender

	def setDefender(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Player import Player
			if not isinstance(value, Player):
				raise TypeError, 'expecting Player, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._defender
		self._defender = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _defenderAttr
			if _defenderAttr is None:
				_defenderAttr = self.klass().lookupAttr('defender')
				if not _defenderAttr.shouldRegisterChanges():
					_defenderAttr = 0
			if _defenderAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['defender'] = _defenderAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def victor(self):
		if self._victor is not None and type(self._victor) is not InstanceType:
			try:
				self.__dict__['_victor'] = self._mk_store.fetchObjRef(self._victor)
			except ObjRefError, e:
				self.__dict__['_victor'] = self.objRefErrorWasRaised(e, 'BattleEvent', 'victor')
		return self._victor

	def setVictor(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Player import Player
			if not isinstance(value, Player):
				raise TypeError, 'expecting Player, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._victor
		self._victor = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _victorAttr
			if _victorAttr is None:
				_victorAttr = self.klass().lookupAttr('victor')
				if not _victorAttr.shouldRegisterChanges():
					_victorAttr = 0
			if _victorAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['victor'] = _victorAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def numAttackingShips(self):
		return self._numAttackingShips

	def setNumAttackingShips(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._numAttackingShips
		self._numAttackingShips = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _numAttackingShipsAttr
			if _numAttackingShipsAttr is None:
				_numAttackingShipsAttr = self.klass().lookupAttr('numAttackingShips')
				if not _numAttackingShipsAttr.shouldRegisterChanges():
					_numAttackingShipsAttr = 0
			if _numAttackingShipsAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['numAttackingShips'] = _numAttackingShipsAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def numDefendingShips(self):
		return self._numDefendingShips

	def setNumDefendingShips(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._numDefendingShips
		self._numDefendingShips = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _numDefendingShipsAttr
			if _numDefendingShipsAttr is None:
				_numDefendingShipsAttr = self.klass().lookupAttr('numDefendingShips')
				if not _numDefendingShipsAttr.shouldRegisterChanges():
					_numDefendingShipsAttr = 0
			if _numDefendingShipsAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['numDefendingShips'] = _numDefendingShipsAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def numShipsLost(self):
		return self._numShipsLost

	def setNumShipsLost(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._numShipsLost
		self._numShipsLost = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _numShipsLostAttr
			if _numShipsLostAttr is None:
				_numShipsLostAttr = self.klass().lookupAttr('numShipsLost')
				if not _numShipsLostAttr.shouldRegisterChanges():
					_numShipsLostAttr = 0
			if _numShipsLostAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['numShipsLost'] = _numShipsLostAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

