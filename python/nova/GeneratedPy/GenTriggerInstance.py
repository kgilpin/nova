'''
GenTriggerInstance.py
Tue Mar 29 11:44:59 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_triggerDefAttr = None
_playerAttr = None
_userFieldValuesAttr = None
_messageTransportAttr = None
_gameAttr = None

import types
from mx import DateTime


from MiddleKit.Run.MiddleObject import MiddleObject
from types import InstanceType, LongType
from MiddleKit.Run.SQLObjectStore import ObjRefError



class GenTriggerInstance(MiddleObject):

	def __init__(self):
		MiddleObject.__init__(self)
		self._triggerDef       = None
		self._player           = None
		self._userFieldValues  = None
		self._messageTransport = None
		self._game             = None

	def construct(self, triggerDef, player, messageTransport, game):
		# Construct the TriggerInstance with all the required attributes that do not have default values
		self.setTriggerDef( triggerDef )
		self.setPlayer( player )
		self.setMessageTransport( messageTransport )
		self.setGame( game )

	def triggerDef(self):
		if self._triggerDef is not None and type(self._triggerDef) is not InstanceType:
			try:
				self.__dict__['_triggerDef'] = self._mk_store.fetchObjRef(self._triggerDef)
			except ObjRefError, e:
				self.__dict__['_triggerDef'] = self.objRefErrorWasRaised(e, 'TriggerInstance', 'triggerDef')
		return self._triggerDef

	def setTriggerDef(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.TriggerDefinition import TriggerDefinition
			if not isinstance(value, TriggerDefinition):
				raise TypeError, 'expecting TriggerDefinition, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._triggerDef
		self._triggerDef = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _triggerDefAttr
			if _triggerDefAttr is None:
				_triggerDefAttr = self.klass().lookupAttr('triggerDef')
				if not _triggerDefAttr.shouldRegisterChanges():
					_triggerDefAttr = 0
			if _triggerDefAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['triggerDef'] = _triggerDefAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def player(self):
		if self._player is not None and type(self._player) is not InstanceType:
			try:
				self.__dict__['_player'] = self._mk_store.fetchObjRef(self._player)
			except ObjRefError, e:
				self.__dict__['_player'] = self.objRefErrorWasRaised(e, 'TriggerInstance', 'player')
		return self._player

	def setPlayer(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Player import Player
			if not isinstance(value, Player):
				raise TypeError, 'expecting Player, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._player
		self._player = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _playerAttr
			if _playerAttr is None:
				_playerAttr = self.klass().lookupAttr('player')
				if not _playerAttr.shouldRegisterChanges():
					_playerAttr = 0
			if _playerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['player'] = _playerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def userFieldValues(self):
		return self._userFieldValues

	def setUserFieldValues(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._userFieldValues
		self._userFieldValues = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _userFieldValuesAttr
			if _userFieldValuesAttr is None:
				_userFieldValuesAttr = self.klass().lookupAttr('userFieldValues')
				if not _userFieldValuesAttr.shouldRegisterChanges():
					_userFieldValuesAttr = 0
			if _userFieldValuesAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['userFieldValues'] = _userFieldValuesAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def messageTransport(self):
		return self._messageTransport

	def setMessageTransport(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._messageTransport
		self._messageTransport = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _messageTransportAttr
			if _messageTransportAttr is None:
				_messageTransportAttr = self.klass().lookupAttr('messageTransport')
				if not _messageTransportAttr.shouldRegisterChanges():
					_messageTransportAttr = 0
			if _messageTransportAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['messageTransport'] = _messageTransportAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def game(self):
		if self._game is not None and type(self._game) is not InstanceType:
			try:
				self.__dict__['_game'] = self._mk_store.fetchObjRef(self._game)
			except ObjRefError, e:
				self.__dict__['_game'] = self.objRefErrorWasRaised(e, 'TriggerInstance', 'game')
		return self._game

	def setGame(self, value):
		assert value is not None
		if value is not None and type(value) is not LongType:
			if not type(value) is InstanceType:
				raise TypeError, 'expecting InstanceType, but got value %r of type %r instead' % (value, type(value))
			from nova.Game import Game
			if not isinstance(value, Game):
				raise TypeError, 'expecting Game, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._game
		self._game = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _gameAttr
			if _gameAttr is None:
				_gameAttr = self.klass().lookupAttr('game')
				if not _gameAttr.shouldRegisterChanges():
					_gameAttr = 0
			if _gameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['game'] = _gameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

