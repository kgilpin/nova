from CodeGenerator import CodeGenerator
from MiscUtils import AbstractError
from time import asctime, localtime, time
import string
import os, sys
from types import *

class JavaGenerator(CodeGenerator):
	"""
	CodeGenerator which generates Java code for the MiddleKit classes. This file should be placed in the directory
	MiddleKit/Design.

	The 'JavaPackage' option in Settings.config may be used to prepend a Java package
	name to all the generated code.
	"""

	def defaultConfig(self):
		return {
			'DestDir': 'GeneratedJava',
		}

	def generate(self, dirname):
		
		if self.model().hasSetting('JavaPackage'):
			package = self.model().setting('JavaPackage')
			dirname += "/%s" % string.replace(package, '.', '/')

		print 'Generating to: %s' % dirname
		
		self.requireDir(dirname)
		# @@ 2000-10-17 ce: ACK! Get rid of all these hard coded 'GeneratedJava' strings
		# @@ 2000-10-16 ce: should delete gen/
		self.requireDir(os.path.join(dirname, 'gen'))
		self.writeInfoFile(os.path.join(dirname, 'gen', 'Info.text'))
		self.model().writeJava(self, dirname)

class Model:

	def writeJava(self, generator, dirname):
		for klass in self._allKlassesInOrder:
			filename = os.path.join(dirname, klass.name()+'.java')
			klass.writeJavaStubIfNeeded(generator, filename)

			filename = os.path.join(dirname, 'gen', 'Gen'+klass.name()+'.java')
			klass.writeJava(generator, filename)

class ModelObject:

	def writeJava(self, generator, out=sys.stdout):
		""" Writes the Java code to define a table for the class. The target can be a file or a filename. """
		if type(out) is StringType:
			out = open(out, 'w')
			close = 1
		else:
			close = 0
		self._writeJava(generator, out)
		if close:
			out.close()


class Klass:

	def javaPackage(self):
		if self._klassContainer._model.hasSetting('JavaPackage'):
			return self._klassContainer._model.setting('JavaPackage')
		else:
			return None

	def writeJavaStubIfNeeded(self, generator, filename):
		if not os.path.exists(filename):
			package = self.javaPackage()
			
			# Grab values for use in writing file
			basename = os.path.basename(filename)
			name = self.name()
			superclassModule = 'gen'
			if package is not None:
				superclassModule = package + '.' + superclassModule
			superclassName = 'Gen' + name

			# Write file
			file = open(filename, 'w')
			file.write(JavaStubTemplate % locals())
			file.close()

	def _writeJava(self, generator, out):
		# Looks like this is not used?
		# self._pyGenerator = generator
		self._javaOut = out
		self.writeJavaFileDocString()
		self.writeJavaPackage()
		self.writeJavaImports()
		self.writeJavaClassDef()

	def writeJavaFileDocString(self):
		wr = self._javaOut.write
		out = self._javaOut
		wr("""/*\n""")
		wr('Gen%s.java\n' % self.name())
		wr('%s\n' % asctime(localtime(time())))
		wr('Generated by MiddleKit.\n') # @@ 2000-10-01 ce: Put the version number here
		wr("""*/\n""")

	def writeJavaPackage(self):
		wr = self._javaOut.write
		package = 'gen'
		if self.javaPackage() is not None:
			package = self.javaPackage() + '.' + package
		wr('package %s;\n\n' % package)

	def writeJavaImports(self):
		wr = self._javaOut.write
		wr('import java.util.Date;\n')
		wr('import java.util.List;\n')
		wr('import java.util.ArrayList;\n')

	def writeJavaClassDef(self):
		wr = self._javaOut.write
		wr(
'''
public class Gen%s
{
'''
			% self.name() )
		self.writeJavaAttrDecls()
		self.writeJavaInit()
		self.writeJavaAccessors()
		wr('}\n')

	def writeJavaAttrDecls(self):

		wr = self._javaOut.write
		for attr in self.allAttrs():
			if attr.defaultValue() is not None:
				wr('\tprivate %s _%s = %s;\n' % ( attr.javaTypeName(), attr.name(), attr.defaultValue() ))
			else:
				wr('\tprivate %s _%s;\n' % ( attr.javaTypeName(), attr.name() ))
		wr('\n')
		
	def writeJavaInit(self):
		# Default attribute values are handled in their declaration
		pass
	
	def writeJavaAccessors(self):
		""" Write Java accessors for attributes simply by asking each one to do so. """
		out = self._javaOut
		for attr in self.attrs():
			attr.writeJavaAccessors(out)

class Attr:

	def defaultValue(self):
		""" Returns the default value as a legal Java value. """
		if self.has_key('Default'):
			default = self['Default']
			if type(default) is type(''):
				default = default.strip()
			if not default:
				return None
			else:
				return self.stringToValue(default)
		else:
			return None

	def pyGetName(self):
		""" Returns the name that should be used for the Java "get" accessor method for this attribute.
		This implementation returns a Java-bean-like method name """
		return 'get' + string.upper(self.name()[0]) + self.name()[1:]

	def pySetName(self):
		""" Returns the name that should be used for the Java "get" accessor method for this attribute.
		This implementation returns a Java-bean-like method name """
		return 'set' + string.upper(self.name()[0]) + self.name()[1:]

	def stringToValue(self, string):
		"""
		Returns a bona fide Java value given a string. Invokers should never pass None or blank strings.
		Used by at least defaultValue().
		Subclass responsibility.
		"""
		raise AbstractError, self.__class__

	def javaTypeName(self):
		"""
		Return the Java type name of the attribute
		"""
		raise AbstractError, self.__class__

	def isObject(self):
		return 0

	def writeJavaAccessors(self, out):
		self.writeJavaGet(out)
		self.writeJavaSet(out)

	def writeJavaGet(self, out):
		out.write('''
	public %s %s()
	{
		return this._%s;
	}
''' % (self.javaTypeName(), self.pyGetName(), self.name()))

	def writeJavaSet(self, out):
		out.write('''
	public void %s(%s newValue)
	{
''' % (self.pySetName(), self.javaTypeName() ))
		self.writeJavaSetChecks(out)
		self.writeJavaSetAssignment(out.write)
		out.write('''
	}
''')

	def writeJavaSetAssignment(self, write):
		write('''
		this._%s = newValue;
''' % self.name() )

	def writeJavaSetChecks(self, out):
		if self.isRequired() and self.isObject():
			out.write('''
		if ( newValue == null ) throw new NullPointerException("%s cannot be null");
		''' % self.name())

JavaStubTemplate = """
/*
%(basename)s
*/

package %(package)s;

import %(superclassModule)s.%(superclassName)s;

public class %(name)s
	extends %(superclassName)s
{
}
"""


class BoolAttr:
	def javaTypeName(self):
		return 'boolean';

	def stringToValue(self, string):
		string = string.upper()
		if string=='TRUE' or string=='YES':
			value = 'true'
		elif string=='FALSE' or string=='NO':
			value = 'false'
		else:
			if int(string) == 0:
				value = 'false'
			else:
				value = 'true'
		return value

class IntAttr:
	def javaTypeName(self):
		return 'int';

	def stringToValue(self, string):
		return int(string)

class LongAttr:
	def javaTypeName(self):
		return 'long';

	def stringToValue(self, string):
		return long(string)

class FloatAttr:
	def javaTypeName(self):
		return 'double';

	def stringToValue(self, string):
		return float(string)

class StringAttr:
	def isObject(self):
		return 1

	def javaTypeName(self):
		return 'String';

	def stringToValue(self, string):
		return '"%s"' % string

class EnumAttr:

	def javaTypeName(self):
		return 'String';

	def stringToValue(self, string):
		return '"%s"' % string

	def writeJavaSetChecks(self, out):
		Attr.writeJavaSetChecks.im_func(self, out)
		out.write('''
		if ( !( false ''')
		for enum in self._enumSet.keys():
			out.write('''
			|| "%s".equals(newValue)''' % enum)
		out.write('''			 
			) )
	   {
			throw new IllegalArgumentException("Value '" + newValue + "' for Enum attribute %s must be in %s");
		}''' % ( self.name(), self._enumSet.keys() ) )

class AnyDateTimeAttr:
	def isObject(self):
		return 1

	def javaTypeName(self):
		return 'java.util.Date';

class ObjRefAttr:
	def isObject(self):
		return 1

	def javaTypeName(self):
		return 'Gen' + self.className()

class ListAttr:
	def isObject(self):
		return 1

	def javaTypeName(self):
		return 'java.util.List';

	def defaultValue(self):
		""" Returns the default value as a legal Java value. """
		assert not self.get('Default', 0), 'Cannot have default values for lists.'
		return ' new ArrayList()'

